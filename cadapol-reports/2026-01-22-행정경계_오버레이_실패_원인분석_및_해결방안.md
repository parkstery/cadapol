# í–‰ì •ê²½ê³„ ì˜¤ë²„ë ˆì´ ê¸°ëŠ¥ ì‹¤íŒ¨ ì›ì¸ ë¶„ì„ ë° í•´ê²°ë°©ì•ˆ

**ì‘ì„±ì¼**: 2026ë…„ 1ì›” 22ì¼  
**í”„ë¡œì íŠ¸ëª…**: Cadapol (Advanced Dual Map Viewer)  
**ë¬¸ì œ**: í–‰ì •ê²½ê³„ ë ˆì´ì–´ ì˜¤ë²„ë ˆì´ ê¸°ëŠ¥ì´ ì •ìƒ ì‘ë™í•˜ì§€ ì•ŠìŒ

---

## ğŸ“‹ ëª©ì°¨

1. [ë¬¸ì œ ê°œìš”](#1-ë¬¸ì œ-ê°œìš”)
2. [ì›ì¸ ë¶„ì„](#2-ì›ì¸-ë¶„ì„)
3. [í•´ê²°ë°©ì•ˆ](#3-í•´ê²°ë°©ì•ˆ)
4. [êµ¬í˜„ ê³„íš](#4-êµ¬í˜„-ê³„íš)
5. [í…ŒìŠ¤íŠ¸ ê³„íš](#5-í…ŒìŠ¤íŠ¸-ê³„íš)

---

## 1. ë¬¸ì œ ê°œìš”

### 1.1 ì¦ìƒ
- í–‰ì •ê²½ê³„ ë ˆì´ì–´ í† ê¸€ ë²„íŠ¼ í´ë¦­ ì‹œ ë ˆì´ì–´ê°€ í‘œì‹œë˜ì§€ ì•ŠìŒ
- ì½˜ì†”ì— ì—ëŸ¬ ë©”ì‹œì§€ê°€ ì¶œë ¥ë˜ê±°ë‚˜ ì¡°ìš©íˆ ì‹¤íŒ¨
- VWorld API í˜¸ì¶œì€ ì„±ê³µí•˜ì§€ë§Œ í´ë¦¬ê³¤ì´ ë§µì— í‘œì‹œë˜ì§€ ì•ŠìŒ

### 1.2 ì˜í–¥ ë²”ìœ„
- ëª¨ë“  ë§µ ì œê³µì (Google, Kakao, Naver)
- ëª¨ë“  í–‰ì •ê²½ê³„ ë ˆë²¨ (ì‹œë„, ì‹œêµ°êµ¬, ìë©´ë™)

---

## 2. ì›ì¸ ë¶„ì„

### 2.1 ğŸ”´ ì£¼ìš” ì›ì¸ 1: ë¹„ë™ê¸° ì²˜ë¦¬ ëˆ„ë½

**ìœ„ì¹˜**: `components/layers/LayerManager.tsx` (Line 29-50)

**ë¬¸ì œ**:
```typescript
addLayer(config: LayerConfig): void {
  // ...
  if (this.mapProvider) {
    layer.attachToMap(this.mapProvider);  // âŒ await ì—†ì´ í˜¸ì¶œ
  }
  this.layers.set(config.id, layer);
}
```

`attachToMap`ì€ `Promise<void>`ë¥¼ ë°˜í™˜í•˜ëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ì´ì§€ë§Œ, `await` ì—†ì´ í˜¸ì¶œë˜ì–´ ì—ëŸ¬ê°€ ë¬´ì‹œë˜ê±°ë‚˜ ë ˆì´ì–´ê°€ ì™„ì „íˆ ë¡œë“œë˜ê¸° ì „ì— ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰ë©ë‹ˆë‹¤.

**ì˜í–¥**: 
- VWorld API í˜¸ì¶œì´ ì™„ë£Œë˜ê¸° ì „ì— ë ˆì´ì–´ê°€ ì¶”ê°€ë¨
- í´ë¦¬ê³¤ ìƒì„±ì´ ì‹¤íŒ¨í•´ë„ ì—ëŸ¬ê°€ ì „íŒŒë˜ì§€ ì•ŠìŒ

---

### 2.2 ğŸ”´ ì£¼ìš” ì›ì¸ 2: ë§µ ì¸ìŠ¤í„´ìŠ¤ ì¤€ë¹„ ìƒíƒœ í™•ì¸ ë¶€ì¡±

**ìœ„ì¹˜**: `components/layers/AdministrativeBoundaryLayer.tsx` (Line 63-109)

**ë¬¸ì œ**:
```typescript
async attachToMap(mapProvider: MapProvider): Promise<void> {
  this.mapProvider = mapProvider;
  const mapInstance = mapProvider.getMapInstance();
  
  if (!mapInstance) {
    throw new Error('Map instance not available');
  }
  
  // 500ms ëŒ€ê¸°ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±í•  ìˆ˜ ìˆìŒ
  await new Promise(resolve => setTimeout(resolve, 500));
  
  let bounds = this.getMapBounds(mapInstance, mapProvider.getName());
  // ...
}
```

**ë¬¸ì œì **:
1. ë§µ ì¸ìŠ¤í„´ìŠ¤ê°€ ì¡´ì¬í•˜ë”ë¼ë„ ì™„ì „íˆ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŒ
2. ê³ ì •ëœ 500ms ëŒ€ê¸° ì‹œê°„ì€ ë§µ ì´ˆê¸°í™” ì†ë„ì— ë”°ë¼ ë¶€ì¡±í•  ìˆ˜ ìˆìŒ
3. `getMapBounds`ê°€ ì‹¤íŒ¨í•´ë„ ê¸°ë³¸ boundsë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ì´ boundsê°€ ì‹¤ì œ ë§µ ì˜ì—­ê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ

**ì˜í–¥**:
- ì˜ëª»ëœ boundsë¡œ ì¸í•´ ì˜ëª»ëœ í–‰ì •ê²½ê³„ ë°ì´í„° ì¡°íšŒ
- ë§µì´ ì¤€ë¹„ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ í´ë¦¬ê³¤ ìƒì„± ì‹œë„

---

### 2.3 ğŸŸ¡ ì›ì¸ 3: VWorld API í˜¸ì¶œ ì‹¤íŒ¨ ì²˜ë¦¬ ë¶€ì¡±

**ìœ„ì¹˜**: `components/utils/vworldApi.ts` (Line 25-85)

**ë¬¸ì œ**:
```typescript
static async getAdministrativeBoundaries(...): Promise<AdministrativeBoundary[]> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    // ...
  } catch (error) {
    console.warn('VWorld API: Fetch failed, trying JSONP', error);
    return this.getAdministrativeBoundariesJSONP(level, bounds);
  }
}
```

**ë¬¸ì œì **:
1. JSONP í´ë°±ë„ ì‹¤íŒ¨í•  ê²½ìš° ë¹ˆ ë°°ì—´ë§Œ ë°˜í™˜
2. API í‚¤ ìœ íš¨ì„± ê²€ì¦ ì—†ìŒ
3. ë„ë©”ì¸ ì œí•œ ë¬¸ì œë¡œ ì¸í•œ ì‹¤íŒ¨ ê°€ëŠ¥ì„±
4. ì—ëŸ¬ ë¡œê¹…ì´ ë¶€ì¡±í•˜ì—¬ ë””ë²„ê¹… ì–´ë ¤ì›€

**ì˜í–¥**:
- API í˜¸ì¶œ ì‹¤íŒ¨ ì‹œ ì¡°ìš©íˆ ë¹ˆ ë°°ì—´ ë°˜í™˜
- ì‚¬ìš©ìì—ê²Œ í”¼ë“œë°± ì—†ìŒ

---

### 2.4 ğŸŸ¡ ì›ì¸ 4: í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ì²˜ë¦¬ ë¶€ì¡±

**ìœ„ì¹˜**: `components/layers/AdministrativeBoundaryLayer.tsx` (Line 99-101, 207-259)

**ë¬¸ì œ**:
```typescript
this.polygons = boundaries.map(boundary => {
  return this.createPolygon(boundary, mapProvider);
});

// createPolygonì—ì„œ null ë°˜í™˜ ê°€ëŠ¥
private createPolygon(...): any {
  // ...
  if (paths.length === 0) return null;  // âŒ null ë°˜í™˜
  // ...
  return null;  // âŒ ì—ëŸ¬ ì‹œ null ë°˜í™˜
}
```

**ë¬¸ì œì **:
1. `createPolygon`ì´ `null`ì„ ë°˜í™˜í•´ë„ ë°°ì—´ì— í¬í•¨ë¨
2. `null` í´ë¦¬ê³¤ì´ `updateVisibility`ì—ì„œ ì²˜ë¦¬ë˜ì§€ ì•ŠìŒ
3. ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ì¡°ìš©íˆ ì‹¤íŒ¨

**ì˜í–¥**:
- ì¼ë¶€ í´ë¦¬ê³¤ë§Œ ìƒì„±ë˜ê³  ë‚˜ë¨¸ì§€ëŠ” ì‹¤íŒ¨í•´ë„ ì•Œ ìˆ˜ ì—†ìŒ
- ë¹ˆ í´ë¦¬ê³¤ ë°°ì—´ë¡œ ì¸í•´ ë ˆì´ì–´ê°€ í‘œì‹œë˜ì§€ ì•ŠìŒ

---

### 2.5 ğŸŸ¡ ì›ì¸ 5: ì¢Œí‘œ ë³€í™˜ ë¬¸ì œ

**ìœ„ì¹˜**: `components/layers/AdministrativeBoundaryLayer.tsx` (Line 261-299)

**ë¬¸ì œ**:
```typescript
private parseGeometry(geometry: any): number[][] {
  // ...
  let isTM = firstPoint[0] > 180 || firstPoint[1] > 90; // âŒ ë‹¨ìˆœí•œ ê°ì§€ ë¡œì§
  // ...
}
```

**ë¬¸ì œì **:
1. ì¢Œí‘œê³„ ê°ì§€ ë¡œì§ì´ ë‹¨ìˆœí•¨ (180ë„, 90ë„ ê¸°ì¤€)
2. EPSG:5179 ì¢Œí‘œê°€ ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ìˆ˜ ìˆìŒ
3. ì¢Œí‘œ ë³€í™˜ ì‹¤íŒ¨ ì‹œ ë¹ˆ ë°°ì—´ ë°˜í™˜

**ì˜í–¥**:
- ì˜ëª»ëœ ì¢Œí‘œë¡œ í´ë¦¬ê³¤ì´ ìƒì„±ë˜ì–´ ì˜ëª»ëœ ìœ„ì¹˜ì— í‘œì‹œ
- ì¢Œí‘œ ë³€í™˜ ì‹¤íŒ¨ë¡œ í´ë¦¬ê³¤ì´ ìƒì„±ë˜ì§€ ì•ŠìŒ

---

### 2.6 ğŸŸ¡ ì›ì¸ 6: ë§µ ì œê³µìë³„ í´ë¦¬ê³¤ ìƒì„± ë¡œì§ ì°¨ì´

**ìœ„ì¹˜**: `components/layers/AdministrativeBoundaryLayer.tsx` (Line 207-259)

**ë¬¸ì œ**:
- Google, Kakao, Naver ê°ê° ë‹¤ë¥¸ API ì‚¬ìš©
- ì¼ë¶€ ë§µ ì œê³µìì—ì„œ í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ê°€ëŠ¥ì„±
- ì—ëŸ¬ ì²˜ë¦¬ ë°©ì‹ì´ ì¼ê´€ë˜ì§€ ì•ŠìŒ

**ì˜í–¥**:
- íŠ¹ì • ë§µ ì œê³µìì—ì„œë§Œ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ

---

## 3. í•´ê²°ë°©ì•ˆ

### 3.1 âœ… í•´ê²°ë°©ì•ˆ 1: ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ 

**ìˆ˜ì • íŒŒì¼**: `components/layers/LayerManager.tsx`

**ë³€ê²½ì‚¬í•­**:
```typescript
async addLayer(config: LayerConfig): Promise<void> {
  if (this.layers.has(config.id)) {
    console.warn(`Layer with id ${config.id} already exists`);
    return;
  }

  let layer: Layer;
  
  switch (config.type) {
    case LayerType.ADMINISTRATIVE_BOUNDARY:
      layer = new AdministrativeBoundaryLayer(config);
      break;
    default:
      throw new Error(`Unsupported layer type: ${config.type}`);
  }
  
  // âœ… ë¹„ë™ê¸° ì²˜ë¦¬ ì¶”ê°€
  try {
    if (this.mapProvider) {
      await layer.attachToMap(this.mapProvider);
    }
    this.layers.set(config.id, layer);
  } catch (error) {
    console.error(`Failed to add layer ${config.id}:`, error);
    throw error; // ì—ëŸ¬ ì „íŒŒ
  }
}
```

**íš¨ê³¼**:
- ë ˆì´ì–´ê°€ ì™„ì „íˆ ë¡œë“œëœ í›„ì—ë§Œ ì¶”ê°€ë¨
- ì—ëŸ¬ê°€ ì œëŒ€ë¡œ ì „íŒŒë˜ì–´ ë””ë²„ê¹… ê°€ëŠ¥

---

### 3.2 âœ… í•´ê²°ë°©ì•ˆ 2: ë§µ ì¤€ë¹„ ìƒíƒœ í™•ì¸ ê°•í™”

**ìˆ˜ì • íŒŒì¼**: `components/layers/AdministrativeBoundaryLayer.tsx`

**ë³€ê²½ì‚¬í•­**:
```typescript
async attachToMap(mapProvider: MapProvider): Promise<void> {
  this.mapProvider = mapProvider;
  const mapInstance = mapProvider.getMapInstance();
  
  if (!mapInstance) {
    throw new Error('Map instance not available');
  }
  
  // âœ… ë§µì´ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
  await this.waitForMapReady(mapInstance, mapProvider.getName());
  
  // âœ… bounds ê°€ì ¸ì˜¤ê¸° ì¬ì‹œë„ ë¡œì§ ê°œì„ 
  let bounds = await this.getMapBoundsWithRetry(mapInstance, mapProvider.getName(), 3);
  
  if (!bounds) {
    console.warn('AdministrativeBoundaryLayer: Cannot get map bounds, using default bounds');
    bounds = {
      minLat: 37.4,
      minLng: 126.8,
      maxLat: 37.7,
      maxLng: 127.2
    };
  }
  
  // VWorld APIë¡œ í–‰ì •ê²½ê³„ ë°ì´í„° ì¡°íšŒ
  const boundaries = await VWorldAPI.getAdministrativeBoundaries(this.level, bounds);
  
  if (boundaries.length === 0) {
    console.warn('AdministrativeBoundaryLayer: No boundaries found for the current area');
    return;
  }
  
  // âœ… null í•„í„°ë§ ë° ì—ëŸ¬ ì²˜ë¦¬
  this.polygons = boundaries
    .map(boundary => {
      try {
        return this.createPolygon(boundary, mapProvider);
      } catch (error) {
        console.error('Failed to create polygon for boundary:', boundary.id, error);
        return null;
      }
    })
    .filter(polygon => polygon !== null);
  
  if (this.polygons.length === 0) {
    console.warn('AdministrativeBoundaryLayer: No polygons were created');
    return;
  }
  
  if (this.config.visible) {
    this.updateVisibility();
  }
}

// âœ… ìƒˆë¡œìš´ í—¬í¼ ë©”ì„œë“œ ì¶”ê°€
private async waitForMapReady(mapInstance: any, providerName: string): Promise<void> {
  const maxAttempts = 10;
  const delay = 200;
  
  for (let i = 0; i < maxAttempts; i++) {
    try {
      if (providerName === 'google') {
        if (mapInstance.getBounds && mapInstance.getCenter) {
          const bounds = mapInstance.getBounds();
          const center = mapInstance.getCenter();
          if (bounds && center) return;
        }
      } else if (providerName === 'kakao') {
        if (mapInstance.getBounds && mapInstance.getCenter) {
          const bounds = mapInstance.getBounds();
          const center = mapInstance.getCenter();
          if (bounds && center) return;
        }
      } else if (providerName === 'naver') {
        if (mapInstance.getBounds && mapInstance.getCenter) {
          const bounds = mapInstance.getBounds();
          const center = mapInstance.getCenter();
          if (bounds && center) return;
        }
      }
    } catch (error) {
      // ê³„ì† ì‹œë„
    }
    await new Promise(resolve => setTimeout(resolve, delay));
  }
  
  throw new Error('Map instance not ready after maximum attempts');
}

private async getMapBoundsWithRetry(
  mapInstance: any,
  providerName: string,
  maxRetries: number
): Promise<{ minLat: number; minLng: number; maxLat: number; maxLng: number } | undefined> {
  for (let i = 0; i < maxRetries; i++) {
    const bounds = this.getMapBounds(mapInstance, providerName);
    if (bounds) return bounds;
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  return undefined;
}
```

**íš¨ê³¼**:
- ë§µì´ ì™„ì „íˆ ì¤€ë¹„ëœ í›„ì—ë§Œ ë ˆì´ì–´ ë¡œë“œ
- bounds ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
- ë” ì•ˆì •ì ì¸ ë ˆì´ì–´ ë¡œë”©

---

### 3.3 âœ… í•´ê²°ë°©ì•ˆ 3: VWorld API ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”

**ìˆ˜ì • íŒŒì¼**: `components/utils/vworldApi.ts`

**ë³€ê²½ì‚¬í•­**:
```typescript
static async getAdministrativeBoundaries(
  level: 'sido' | 'sigungu' | 'emd',
  bounds?: { minLat: number; minLng: number; maxLat: number; maxLng: number }
): Promise<AdministrativeBoundary[]> {
  // ... ê¸°ì¡´ ì½”ë“œ ...
  
  try {
    const response = await fetch(url);
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`VWorld API HTTP error: ${response.status}`, errorText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // âœ… ì‘ë‹µ ê²€ì¦ ê°•í™”
    if (!data || !data.response) {
      throw new Error('Invalid API response format');
    }
    
    if (data.response.status !== 'OK') {
      console.error('VWorld API error:', data.response);
      throw new Error(`API error: ${data.response.status}`);
    }
    
    if (!data.response.result || !data.response.result.featureCollection) {
      console.warn('VWorld API: No feature collection in response');
      return [];
    }
    
    const features = data.response.result.featureCollection.features || [];
    
    if (features.length === 0) {
      console.warn('VWorld API: No features found for the specified bounds');
      return [];
    }
    
    const boundaries: AdministrativeBoundary[] = features.map((feature: any, index: number) => {
      // ... ê¸°ì¡´ ë§¤í•‘ ë¡œì§ ...
    });
    
    console.log(`VWorld API: Loaded ${boundaries.length} boundaries`);
    return boundaries;
  } catch (error) {
    console.error('VWorld API: Fetch failed', error);
    // âœ… JSONP í´ë°± ì‹œë„
    try {
      return await this.getAdministrativeBoundariesJSONP(level, bounds);
    } catch (jsonpError) {
      console.error('VWorld API: Both fetch and JSONP failed', jsonpError);
      throw new Error('Failed to load administrative boundaries: ' + (error as Error).message);
    }
  }
}
```

**íš¨ê³¼**:
- ìƒì„¸í•œ ì—ëŸ¬ ë¡œê¹…
- API ì‘ë‹µ ê²€ì¦ ê°•í™”
- ì‹¤íŒ¨ ì›ì¸ íŒŒì•… ìš©ì´

---

### 3.4 âœ… í•´ê²°ë°©ì•ˆ 4: í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ì²˜ë¦¬ ê°œì„ 

**ìˆ˜ì • íŒŒì¼**: `components/layers/AdministrativeBoundaryLayer.tsx`

**ë³€ê²½ì‚¬í•­**:
```typescript
private createPolygon(boundary: AdministrativeBoundary, mapProvider: MapProvider): any {
  const mapInstance = mapProvider.getMapInstance();
  const providerName = mapProvider.getName();
  
  if (!mapInstance) {
    console.error('Map instance not available for polygon creation');
    return null;
  }
  
  try {
    const paths = this.parseGeometry(boundary.geometry);
    
    if (paths.length === 0) {
      console.warn(`No paths found for boundary: ${boundary.id}`);
      return null;
    }
    
    // âœ… ìµœì†Œ 3ê°œ ì  í•„ìš” (í´ë¦¬ê³¤)
    if (paths.length < 3) {
      console.warn(`Insufficient points for polygon: ${boundary.id} (${paths.length} points)`);
      return null;
    }
    
    let polygon: any = null;
    
    if (providerName === 'google') {
      polygon = new window.google.maps.Polygon({
        paths: paths.map(p => ({ lat: p[1], lng: p[0] })),
        strokeColor: '#4285F4',
        strokeOpacity: this.config.opacity,
        strokeWeight: 2,
        fillColor: '#4285F4',
        fillOpacity: this.config.opacity * 0.2,
        map: this.config.visible ? mapInstance : null,
        zIndex: this.config.zIndex
      });
    } else if (providerName === 'kakao') {
      const kakaoPaths = paths.map(p => new window.kakao.maps.LatLng(p[1], p[0]));
      polygon = new window.kakao.maps.Polygon({
        path: kakaoPaths,
        strokeWeight: 2,
        strokeColor: '#4285F4',
        strokeOpacity: this.config.opacity,
        strokeStyle: 'solid',
        fillColor: '#4285F4',
        fillOpacity: this.config.opacity * 0.2,
        map: this.config.visible ? mapInstance : null,
        zIndex: this.config.zIndex
      });
    } else if (providerName === 'naver') {
      const naverPaths = paths.map(p => new window.naver.maps.LatLng(p[1], p[0]));
      polygon = new window.naver.maps.Polygon({
        paths: naverPaths,
        strokeColor: '#4285F4',
        strokeOpacity: this.config.opacity,
        strokeWeight: 2,
        fillColor: '#4285F4',
        fillOpacity: this.config.opacity * 0.2,
        map: this.config.visible ? mapInstance : null,
        zIndex: this.config.zIndex
      });
    } else {
      console.error(`Unsupported map provider: ${providerName}`);
      return null;
    }
    
    return polygon;
  } catch (error) {
    console.error(`Failed to create polygon for boundary ${boundary.id}:`, error);
    return null;
  }
}
```

**íš¨ê³¼**:
- í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ì‹œ ëª…í™•í•œ ë¡œê¹…
- ìµœì†Œ ìš”êµ¬ì‚¬í•­ ê²€ì¦
- ë¶€ë¶„ ì‹¤íŒ¨ ì‹œì—ë„ ì¼ë¶€ í´ë¦¬ê³¤ì€ í‘œì‹œ

---

### 3.5 âœ… í•´ê²°ë°©ì•ˆ 5: ì¢Œí‘œ ë³€í™˜ ë¡œì§ ê°œì„ 

**ìˆ˜ì • íŒŒì¼**: `components/layers/AdministrativeBoundaryLayer.tsx`

**ë³€ê²½ì‚¬í•­**:
```typescript
private parseGeometry(geometry: any): number[][] {
  if (!geometry || !geometry.coordinates) {
    console.warn('Invalid geometry: missing coordinates');
    return [];
  }
  
  try {
    if (geometry.type === 'Polygon') {
      const outerRing = geometry.coordinates[0];
      if (!outerRing || outerRing.length === 0) {
        console.warn('Empty polygon ring');
        return [];
      }
      
      // âœ… ì¢Œí‘œê³„ ê°ì§€ ê°œì„ 
      const firstPoint = outerRing[0];
      const isTM = this.detectTMCoordinateSystem(firstPoint);
      
      if (isTM && proj4) {
        try {
          proj4.defs("EPSG:5179", "+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs");
          const proj = proj4("EPSG:5179", "EPSG:4326");
          return outerRing.map((coord: number[]) => {
            try {
              const [lon, lat] = proj.forward([coord[0], coord[1]]);
              // âœ… ì¢Œí‘œ ìœ íš¨ì„± ê²€ì¦
              if (isNaN(lon) || isNaN(lat) || !isFinite(lon) || !isFinite(lat)) {
                console.warn('Invalid converted coordinate:', coord);
                return null;
              }
              // âœ… ê²½ë„/ìœ„ë„ ë²”ìœ„ ê²€ì¦
              if (lon < -180 || lon > 180 || lat < -90 || lat > 90) {
                console.warn('Coordinate out of range:', { lon, lat });
                return null;
              }
              return [lon, lat];
            } catch (e) {
              console.error('Coordinate conversion error:', e, coord);
              return null;
            }
          }).filter(coord => coord !== null) as number[][];
        } catch (e) {
          console.error("Proj4 conversion error", e);
          return [];
        }
      } else {
        // âœ… ì´ë¯¸ WGS84ì¸ ê²½ìš°ì—ë„ ìœ íš¨ì„± ê²€ì¦
        return outerRing
          .map((coord: number[]) => {
            const [lon, lat] = coord;
            if (lon < -180 || lon > 180 || lat < -90 || lat > 90) {
              console.warn('Coordinate out of range:', coord);
              return null;
            }
            return [lon, lat];
          })
          .filter(coord => coord !== null) as number[][];
      }
    } else if (geometry.type === 'MultiPolygon') {
      if (geometry.coordinates && geometry.coordinates.length > 0) {
        return this.parseGeometry({ type: 'Polygon', coordinates: geometry.coordinates[0] });
      }
    } else {
      console.warn(`Unsupported geometry type: ${geometry.type}`);
    }
  } catch (e) {
    console.error("Geometry parsing error", e);
  }
  
  return [];
}

// âœ… ìƒˆë¡œìš´ ì¢Œí‘œê³„ ê°ì§€ ë©”ì„œë“œ
private detectTMCoordinateSystem(point: number[]): boolean {
  if (!point || point.length < 2) return false;
  
  const [x, y] = point;
  
  // EPSG:5179 (TM) ì¢Œí‘œ ë²”ìœ„: ëŒ€ëµ x: 100000~2000000, y: 100000~3000000
  // WGS84 ì¢Œí‘œ ë²”ìœ„: ê²½ë„ -180~180, ìœ„ë„ -90~90
  if (Math.abs(x) > 180 || Math.abs(y) > 90) {
    // ê²½ë„/ìœ„ë„ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ TM ì¢Œí‘œë¡œ ê°„ì£¼
    return true;
  }
  
  // ì¶”ê°€ ê²€ì¦: TM ì¢Œí‘œëŠ” ë³´í†µ í° ê°’
  if (Math.abs(x) > 100000 || Math.abs(y) > 100000) {
    return true;
  }
  
  return false;
}
```

**íš¨ê³¼**:
- ë” ì •í™•í•œ ì¢Œí‘œê³„ ê°ì§€
- ì¢Œí‘œ ìœ íš¨ì„± ê²€ì¦ ê°•í™”
- ì˜ëª»ëœ ì¢Œí‘œ í•„í„°ë§

---

### 3.6 âœ… í•´ê²°ë°©ì•ˆ 6: MapPaneì—ì„œ ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€

**ìˆ˜ì • íŒŒì¼**: `components/MapPane.tsx`

**ë³€ê²½ì‚¬í•­**:
```typescript
<button
  onClick={async () => {
    const newState = !isAdministrativeLayerOn;
    setIsAdministrativeLayerOn(newState);
    
    try {
      if (newState) {
        // í–‰ì •ê²½ê³„ ë ˆì´ì–´ ì¶”ê°€
        const layerConfig = createDefaultLayerConfig(
          LayerType.ADMINISTRATIVE_BOUNDARY,
          'í–‰ì •ê²½ê³„',
          { options: { level: 'sido' } }
        );
        // âœ… await ì¶”ê°€
        await layerManagerRef.current.addLayer(layerConfig);
        console.log('Administrative boundary layer added successfully');
      } else {
        // í–‰ì •ê²½ê³„ ë ˆì´ì–´ ì œê±°
        const layers = layerManagerRef.current.getAllLayers();
        layers.forEach(layer => {
          if (layer.getType() === LayerType.ADMINISTRATIVE_BOUNDARY) {
            layerManagerRef.current.removeLayer(layer.getId());
          }
        });
      }
    } catch (error) {
      console.error('Failed to toggle administrative boundary layer:', error);
      // âœ… ì‚¬ìš©ìì—ê²Œ í”¼ë“œë°± (ì„ íƒì‚¬í•­)
      alert('í–‰ì •ê²½ê³„ ë ˆì´ì–´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
      setIsAdministrativeLayerOn(!newState); // ìƒíƒœ ë¡¤ë°±
    }
  }}
  // ...
>
```

**íš¨ê³¼**:
- ì—ëŸ¬ê°€ ì‚¬ìš©ìì—ê²Œ ì „ë‹¬ë¨
- ìƒíƒœ ë¡¤ë°±ìœ¼ë¡œ UI ì¼ê´€ì„± ìœ ì§€

---

## 4. êµ¬í˜„ ê³„íš

### 4.1 ìš°ì„ ìˆœìœ„

1. **ë†’ì€ ìš°ì„ ìˆœìœ„** (ì¦‰ì‹œ ìˆ˜ì •)
   - í•´ê²°ë°©ì•ˆ 1: ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ 
   - í•´ê²°ë°©ì•ˆ 2: ë§µ ì¤€ë¹„ ìƒíƒœ í™•ì¸ ê°•í™”
   - í•´ê²°ë°©ì•ˆ 4: í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ì²˜ë¦¬ ê°œì„ 

2. **ì¤‘ê°„ ìš°ì„ ìˆœìœ„** (1-2ì¼ ë‚´)
   - í•´ê²°ë°©ì•ˆ 3: VWorld API ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”
   - í•´ê²°ë°©ì•ˆ 6: MapPaneì—ì„œ ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€

3. **ë‚®ì€ ìš°ì„ ìˆœìœ„** (í–¥í›„ ê°œì„ )
   - í•´ê²°ë°©ì•ˆ 5: ì¢Œí‘œ ë³€í™˜ ë¡œì§ ê°œì„ 

### 4.2 ì˜ˆìƒ ì‘ì—… ì‹œê°„

- ë†’ì€ ìš°ì„ ìˆœìœ„: 4-6ì‹œê°„
- ì¤‘ê°„ ìš°ì„ ìˆœìœ„: 2-3ì‹œê°„
- ë‚®ì€ ìš°ì„ ìˆœìœ„: 3-4ì‹œê°„
- **ì´ ì˜ˆìƒ ì‹œê°„**: 9-13ì‹œê°„

---

## 5. í…ŒìŠ¤íŠ¸ ê³„íš

### 5.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

1. **LayerManager.addLayer í…ŒìŠ¤íŠ¸**
   - ë¹„ë™ê¸° ì²˜ë¦¬ í™•ì¸
   - ì—ëŸ¬ ì „íŒŒ í™•ì¸

2. **AdministrativeBoundaryLayer.attachToMap í…ŒìŠ¤íŠ¸**
   - ë§µ ì¤€ë¹„ ìƒíƒœ ëŒ€ê¸° í™•ì¸
   - bounds ê°€ì ¸ì˜¤ê¸° ì¬ì‹œë„ í™•ì¸
   - í´ë¦¬ê³¤ ìƒì„± ì„±ê³µ/ì‹¤íŒ¨ ì¼€ì´ìŠ¤

3. **VWorldAPI.getAdministrativeBoundaries í…ŒìŠ¤íŠ¸**
   - API í˜¸ì¶œ ì„±ê³µ ì¼€ì´ìŠ¤
   - API í˜¸ì¶œ ì‹¤íŒ¨ ì¼€ì´ìŠ¤ (fetch ì‹¤íŒ¨ â†’ JSONP í´ë°±)
   - ë¹ˆ ì‘ë‹µ ì²˜ë¦¬

### 5.2 í†µí•© í…ŒìŠ¤íŠ¸

1. **Google Mapsì—ì„œ í–‰ì •ê²½ê³„ ë ˆì´ì–´ í‘œì‹œ**
2. **Kakao Mapsì—ì„œ í–‰ì •ê²½ê³„ ë ˆì´ì–´ í‘œì‹œ**
3. **Naver Mapsì—ì„œ í–‰ì •ê²½ê³„ ë ˆì´ì–´ í‘œì‹œ**
4. **ë ˆì´ì–´ í† ê¸€ (ì¼œê¸°/ë„ê¸°)**
5. **ë§µ ì´ë™ ì‹œ ë ˆì´ì–´ ìœ ì§€**
6. **ë§µ ì œê³µì ë³€ê²½ ì‹œ ë ˆì´ì–´ ì •ë¦¬**

### 5.3 ì—ëŸ¬ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸

1. **ë§µì´ ì¤€ë¹„ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ë ˆì´ì–´ ì¶”ê°€**
2. **VWorld API í˜¸ì¶œ ì‹¤íŒ¨**
3. **ì¢Œí‘œ ë³€í™˜ ì‹¤íŒ¨**
4. **í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨**

---

## 6. ì¶”ê°€ ê°œì„  ì‚¬í•­ (ì„ íƒì‚¬í•­)

### 6.1 ë¡œë”© ìƒíƒœ í‘œì‹œ
- ë ˆì´ì–´ ë¡œë”© ì¤‘ ìŠ¤í”¼ë„ˆ í‘œì‹œ
- ì§„í–‰ë¥  í‘œì‹œ

### 6.2 ì‚¬ìš©ì í”¼ë“œë°±
- ë ˆì´ì–´ ë¡œë“œ ì„±ê³µ/ì‹¤íŒ¨ í† ìŠ¤íŠ¸ ë©”ì‹œì§€
- ì—ëŸ¬ ë°œìƒ ì‹œ ìƒì„¸ ë©”ì‹œì§€

### 6.3 ì„±ëŠ¥ ìµœì í™”
- í–‰ì •ê²½ê³„ ë°ì´í„° ìºì‹±
- ë§µ ì´ë™ ì‹œ ë ˆì´ì–´ ì—…ë°ì´íŠ¸ (debounce)
- ëŒ€ëŸ‰ í´ë¦¬ê³¤ ë Œë”ë§ ìµœì í™”

---

## 7. ê²°ë¡ 

í–‰ì •ê²½ê³„ ì˜¤ë²„ë ˆì´ ê¸°ëŠ¥ ì‹¤íŒ¨ì˜ ì£¼ìš” ì›ì¸ì€ **ë¹„ë™ê¸° ì²˜ë¦¬ ëˆ„ë½**, **ë§µ ì¤€ë¹„ ìƒíƒœ í™•ì¸ ë¶€ì¡±**, **ì—ëŸ¬ ì²˜ë¦¬ ë¶€ì¡±**ì…ë‹ˆë‹¤.

**ì¦‰ì‹œ ìˆ˜ì •í•´ì•¼ í•  ì‚¬í•­**:
1. `LayerManager.addLayer`ì— `async/await` ì¶”ê°€
2. `AdministrativeBoundaryLayer.attachToMap`ì—ì„œ ë§µ ì¤€ë¹„ ìƒíƒœ í™•ì¸ ê°•í™”
3. í´ë¦¬ê³¤ ìƒì„± ì‹¤íŒ¨ ì²˜ë¦¬ ê°œì„ 

**ì˜ˆìƒ íš¨ê³¼**:
- ë ˆì´ì–´ê°€ ì•ˆì •ì ìœ¼ë¡œ ë¡œë“œë¨
- ì—ëŸ¬ ë°œìƒ ì‹œ ì›ì¸ íŒŒì•… ìš©ì´
- ì‚¬ìš©ì ê²½í—˜ ê°œì„ 

---

**ì‘ì„±ì¼**: 2026ë…„ 1ì›” 22ì¼  
**ìµœì¢… ìˆ˜ì •ì¼**: 2026ë…„ 1ì›” 22ì¼  
**ë¬¸ì„œ ë²„ì „**: 1.0
