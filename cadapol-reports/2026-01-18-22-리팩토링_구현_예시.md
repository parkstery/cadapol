# ë¦¬íŒ©í† ë§ êµ¬í˜„ ì˜ˆì‹œ ì½”ë“œ

**ì‘ì„±ì¼**: 2026ë…„ 1ì›” 18ì¼  
**ëª©ì **: í™•ì¥ì„± ê³ ë ¤ ë¦¬íŒ©í† ë§ì˜ êµ¬ì²´ì  êµ¬í˜„ ê°€ì´ë“œ

---

## 1. íƒ€ì… ì •ì˜ í™•ì¥

### types.ts (í™•ì¥ ë²„ì „)

```typescript
// types.ts

export type MapVendor = 'google' | 'kakao' | 'naver' | 'vworld' | 'osm';

export interface MapState {
  lat: number;
  lng: number;
  zoom: number;
}

export interface PaneConfig {
  type: MapVendor;
  isSatellite: boolean;
}

// ğŸ†• ë ˆì´ì–´ ê´€ë ¨ íƒ€ì…
export enum LayerType {
  CADASTRAL = 'cadastral',
  ADMINISTRATIVE_BOUNDARY = 'administrative_boundary',
  TOPOGRAPHIC = 'topographic',
  CUSTOM = 'custom'
}

export interface LayerConfig {
  id: string;
  type: LayerType;
  name: string;
  visible: boolean;
  opacity: number;
  zIndex: number;
  provider?: MapVendor;
}

// ğŸ†• ê¸¸ì°¾ê¸° ê´€ë ¨ íƒ€ì…
export interface Waypoint {
  id: string;
  position: { lat: number; lng: number };
  label?: string;
  order: number;
}

export interface RouteOptions {
  waypoints: Waypoint[];
  travelMode?: 'driving' | 'walking' | 'transit' | 'bicycling';
  avoidTolls?: boolean;
  avoidHighways?: boolean;
  optimizeWaypoints?: boolean;
}

export interface Route {
  id: string;
  distance: number;
  duration: number;
  polyline: Array<{ lat: number; lng: number }>;
  steps?: RouteStep[];
}

export interface RouteStep {
  instruction: string;
  distance: number;
  duration: number;
  polyline: Array<{ lat: number; lng: number }>;
}
```

---

## 2. VWorld Map Provider êµ¬í˜„ ì˜ˆì‹œ

### map-providers/VWorldMapProvider.tsx

```typescript
// map-providers/VWorldMapProvider.tsx

import { BaseMapProvider, MapProvider, MapProviderConfig, MapState, MapCapabilities } from './BaseMapProvider';
import { Layer } from '../../layers/BaseLayer';

export class VWorldMapProvider implements MapProvider {
  private map: any = null;
  private config: MapProviderConfig | null = null;
  private layers: Map<string, Layer> = new Map();
  private markers: Map<string, any> = new Map();
  private listeners: Array<{ event: string; handler: Function }> = [];
  
  async init(config: MapProviderConfig): Promise<void> {
    this.config = config;
    
    // VWorld Map SDK ë¡œë“œ ëŒ€ê¸°
    await this.waitForSDK();
    
    // VWorld Map ì´ˆê¸°í™”
    const vworld = (window as any).vworld;
    if (!vworld) {
      throw new Error('VWorld Map SDK not loaded');
    }
    
    this.map = new vworld.map.Map(config.container, {
      center: new vworld.map.LatLng(config.initialState.lat, config.initialState.lng),
      zoom: config.initialState.zoom,
      mapTypeId: config.isSatellite ? vworld.map.MapTypeId.SATELLITE : vworld.map.MapTypeId.NORMAL,
    });
    
    this.setupListeners();
  }
  
  private async waitForSDK(): Promise<void> {
    return new Promise((resolve, reject) => {
      if ((window as any).vworld) {
        resolve();
        return;
      }
      
      const checkInterval = setInterval(() => {
        if ((window as any).vworld) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      
      setTimeout(() => {
        clearInterval(checkInterval);
        reject(new Error('VWorld SDK load timeout'));
      }, 10000);
    });
  }
  
  private setupListeners(): void {
    if (!this.map || !this.config) return;
    
    // center_changed
    const centerListener = this.map.on('center_changed', () => {
      if (this.config) {
        const center = this.map.getCenter();
        const state: MapState = {
          lat: center.getLat(),
          lng: center.getLng(),
          zoom: this.map.getZoom(),
        };
        this.config.onStateChange(state);
      }
    });
    this.listeners.push({ event: 'center_changed', handler: centerListener });
    
    // zoom_changed
    const zoomListener = this.map.on('zoom_changed', () => {
      if (this.config) {
        const center = this.map.getCenter();
        const state: MapState = {
          lat: center.getLat(),
          lng: center.getLng(),
          zoom: this.map.getZoom(),
        };
        this.config.onStateChange(state);
      }
    });
    this.listeners.push({ event: 'zoom_changed', handler: zoomListener });
  }
  
  syncState(state: MapState): void {
    if (!this.map) return;
    
    this.map.setCenter(new (window as any).vworld.map.LatLng(state.lat, state.lng));
    this.map.setZoom(state.zoom);
  }
  
  getState(): MapState {
    if (!this.map) {
      throw new Error('Map not initialized');
    }
    
    const center = this.map.getCenter();
    return {
      lat: center.getLat(),
      lng: center.getLng(),
      zoom: this.map.getZoom(),
    };
  }
  
  setSatelliteMode(enabled: boolean): void {
    if (!this.map) return;
    
    const vworld = (window as any).vworld;
    this.map.setMapTypeId(enabled ? vworld.map.MapTypeId.SATELLITE : vworld.map.MapTypeId.NORMAL);
  }
  
  setZoom(zoom: number): void {
    if (this.map) {
      this.map.setZoom(zoom);
    }
  }
  
  setCenter(lat: number, lng: number): void {
    if (this.map) {
      this.map.setCenter(new (window as any).vworld.map.LatLng(lat, lng));
    }
  }
  
  setMarker(position: { lat: number; lng: number } | null): void {
    // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
    this.markers.forEach(marker => marker.setMap(null));
    this.markers.clear();
    
    if (position && this.map) {
      const vworld = (window as any).vworld;
      const marker = new vworld.map.Marker({
        position: new vworld.map.LatLng(position.lat, position.lng),
        map: this.map,
      });
      this.markers.set('default', marker);
    }
  }
  
  addLayer(layer: Layer): void {
    this.layers.set(layer.getId(), layer);
    layer.attachToMap(this);
  }
  
  removeLayer(layer: Layer): void {
    const existingLayer = this.layers.get(layer.getId());
    if (existingLayer) {
      existingLayer.detachFromMap();
      this.layers.delete(layer.getId());
    }
  }
  
  getLayers(): Layer[] {
    return Array.from(this.layers.values());
  }
  
  on(event: string, handler: Function): void {
    if (this.map) {
      this.map.on(event, handler);
      this.listeners.push({ event, handler });
    }
  }
  
  off(event: string, handler: Function): void {
    if (this.map) {
      this.map.off(event, handler);
      this.listeners = this.listeners.filter(l => l.event !== event || l.handler !== handler);
    }
  }
  
  cleanup(): void {
    // ë¦¬ìŠ¤ë„ˆ ì œê±°
    this.listeners.forEach(({ event, handler }) => {
      if (this.map) {
        this.map.off(event, handler);
      }
    });
    this.listeners = [];
    
    // ë ˆì´ì–´ ì œê±°
    this.layers.forEach(layer => {
      layer.detachFromMap();
      layer.cleanup();
    });
    this.layers.clear();
    
    // ë§ˆì»¤ ì œê±°
    this.markers.forEach(marker => marker.setMap(null));
    this.markers.clear();
    
    this.map = null;
    this.config = null;
  }
  
  getMapInstance(): any {
    return this.map;
  }
  
  getName(): string {
    return 'VWorld';
  }
  
  getCapabilities(): MapCapabilities {
    return {
      supportsStreetView: false,
      supportsRouting: false,
      supportsLayers: true,
      supportedLayerTypes: ['cadastral', 'administrative_boundary', 'topographic'],
    };
  }
}
```

---

## 3. OSM Map Provider êµ¬í˜„ ì˜ˆì‹œ

### map-providers/OSMMapProvider.tsx

```typescript
// map-providers/OSMMapProvider.tsx

import { BaseMapProvider, MapProvider, MapProviderConfig, MapState, MapCapabilities } from './BaseMapProvider';
import { Layer } from '../../layers/BaseLayer';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

export class OSMMapProvider implements MapProvider {
  private map: L.Map | null = null;
  private config: MapProviderConfig | null = null;
  private layers: Map<string, Layer> = new Map();
  private markers: Map<string, L.Marker> = new Map();
  private tileLayer: L.TileLayer | null = null;
  
  async init(config: MapProviderConfig): Promise<void> {
    this.config = config;
    
    // Leaflet Map ì´ˆê¸°í™”
    this.map = L.map(config.container, {
      center: [config.initialState.lat, config.initialState.lng],
      zoom: config.initialState.zoom,
    });
    
    // OSM íƒ€ì¼ ë ˆì´ì–´ ì¶”ê°€
    this.tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors',
      maxZoom: 19,
    });
    this.tileLayer.addTo(this.map);
    
    // ìœ„ì„± ëª¨ë“œ ì„¤ì •
    if (config.isSatellite) {
      this.setSatelliteMode(true);
    }
    
    this.setupListeners();
  }
  
  private setupListeners(): void {
    if (!this.map || !this.config) return;
    
    // moveend ì´ë²¤íŠ¸ (center_changed + zoom_changed)
    this.map.on('moveend', () => {
      if (this.config && this.map) {
        const center = this.map.getCenter();
        const state: MapState = {
          lat: center.lat,
          lng: center.lng,
          zoom: this.map.getZoom(),
        };
        this.config.onStateChange(state);
      }
    });
  }
  
  syncState(state: MapState): void {
    if (!this.map) return;
    
    this.map.setView([state.lat, state.lng], state.zoom);
  }
  
  getState(): MapState {
    if (!this.map) {
      throw new Error('Map not initialized');
    }
    
    const center = this.map.getCenter();
    return {
      lat: center.lat,
      lng: center.lng,
      zoom: this.map.getZoom(),
    };
  }
  
  setSatelliteMode(enabled: boolean): void {
    if (!this.map || !this.tileLayer) return;
    
    this.tileLayer.remove();
    
    if (enabled) {
      // ìœ„ì„± ì´ë¯¸ì§€ íƒ€ì¼ (ì˜ˆ: Esri World Imagery)
      this.tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Â© Esri',
        maxZoom: 19,
      });
    } else {
      // ì¼ë°˜ OSM íƒ€ì¼
      this.tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors',
        maxZoom: 19,
      });
    }
    
    this.tileLayer.addTo(this.map);
  }
  
  setZoom(zoom: number): void {
    if (this.map) {
      this.map.setZoom(zoom);
    }
  }
  
  setCenter(lat: number, lng: number): void {
    if (this.map) {
      this.map.setView([lat, lng], this.map.getZoom());
    }
  }
  
  setMarker(position: { lat: number; lng: number } | null): void {
    this.markers.forEach(marker => this.map?.removeLayer(marker));
    this.markers.clear();
    
    if (position && this.map) {
      const marker = L.marker([position.lat, position.lng]).addTo(this.map);
      this.markers.set('default', marker);
    }
  }
  
  addLayer(layer: Layer): void {
    this.layers.set(layer.getId(), layer);
    layer.attachToMap(this);
  }
  
  removeLayer(layer: Layer): void {
    const existingLayer = this.layers.get(layer.getId());
    if (existingLayer) {
      existingLayer.detachFromMap();
      this.layers.delete(layer.getId());
    }
  }
  
  getLayers(): Layer[] {
    return Array.from(this.layers.values());
  }
  
  on(event: string, handler: Function): void {
    if (this.map) {
      this.map.on(event, handler);
    }
  }
  
  off(event: string, handler: Function): void {
    if (this.map) {
      this.map.off(event, handler);
    }
  }
  
  cleanup(): void {
    this.layers.forEach(layer => {
      layer.detachFromMap();
      layer.cleanup();
    });
    this.layers.clear();
    
    this.markers.forEach(marker => this.map?.removeLayer(marker));
    this.markers.clear();
    
    if (this.map) {
      this.map.remove();
      this.map = null;
    }
    
    this.config = null;
  }
  
  getMapInstance(): L.Map | null {
    return this.map;
  }
  
  getName(): string {
    return 'OpenStreetMap';
  }
  
  getCapabilities(): MapCapabilities {
    return {
      supportsStreetView: false,
      supportsRouting: true,  // OSRM ë“± ì‚¬ìš© ê°€ëŠ¥
      supportsLayers: true,
      supportedLayerTypes: ['administrative_boundary', 'topographic', 'custom'],
    };
  }
}
```

---

## 4. ê¸¸ì°¾ê¸° Provider êµ¬í˜„ ì˜ˆì‹œ

### routing/providers/KakaoRoutingProvider.tsx

```typescript
// routing/providers/KakaoRoutingProvider.tsx

import { BaseRoutingProvider, RoutingProvider, RouteOptions, Route, RouteStep, RouteDisplay } from '../BaseRoutingProvider';
import { MapProvider } from '../../../map-providers/BaseMapProvider';

export class KakaoRoutingProvider implements RoutingProvider {
  private routeDisplays: Map<string, RouteDisplay> = new Map();
  
  async calculateRoute(options: RouteOptions): Promise<Route[]> {
    if (!window.kakao || !window.kakao.maps || !window.kakao.maps.services) {
      throw new Error('Kakao Maps SDK not loaded');
    }
    
    const directionsService = new window.kakao.maps.services.Directions();
    
    return new Promise((resolve, reject) => {
      // ì¶œë°œì§€, ëª©ì ì§€, ê²½ìœ ì§€ ì„¤ì •
      const waypoints = options.waypoints.sort((a, b) => a.order - b.order);
      const origin = waypoints[0];
      const destination = waypoints[waypoints.length - 1];
      const waypointsList = waypoints.slice(1, -1);
      
      const request = {
        origin: new window.kakao.maps.LatLng(origin.position.lat, origin.position.lng),
        destination: new window.kakao.maps.LatLng(destination.position.lat, destination.position.lng),
        waypoints: waypointsList.length > 0 ? waypointsList.map(wp => ({
          x: wp.position.lng,
          y: wp.position.lat,
        })) : undefined,
        priority: this.mapTravelModeToKakao(options.travelMode || 'driving'),
      };
      
      directionsService.route(request, (result: any, status: any) => {
        if (status === window.kakao.maps.services.Status.OK) {
          const routes: Route[] = result.routes.map((route: any, index: number) => {
            const path: Array<{ lat: number; lng: number }> = [];
            
            // ê²½ë¡œ ì¢Œí‘œ ì¶”ì¶œ
            route.sections.forEach((section: any) => {
              section.roads.forEach((road: any) => {
                road.vertexes.forEach((vertex: any, i: number) => {
                  if (i % 2 === 0) {
                    path.push({
                      lat: vertex,
                      lng: road.vertexes[i + 1],
                    });
                  }
                });
              });
            });
            
            // ë‹¨ê³„ë³„ ì •ë³´ ì¶”ì¶œ
            const steps: RouteStep[] = route.sections.flatMap((section: any) =>
              section.roads.map((road: any) => ({
                instruction: road.name || '',
                distance: road.distance || 0,
                duration: road.duration || 0,
                polyline: [], // í•„ìš”ì‹œ ì¶”ê°€
              }))
            );
            
            return {
              id: `route-${index}`,
              distance: route.summary?.distance || 0,
              duration: route.summary?.duration || 0,
              polyline: path,
              steps,
            };
          });
          
          resolve(routes);
        } else {
          reject(new Error(`Kakao routing failed: ${status}`));
        }
      });
    });
  }
  
  displayRoute(route: Route, mapProvider: MapProvider): RouteDisplay {
    const mapInstance = mapProvider.getMapInstance();
    if (!mapInstance || !window.kakao) {
      throw new Error('Map instance not available');
    }
    
    // ê²½ë¡œë¥¼ Polylineìœ¼ë¡œ í‘œì‹œ
    const path = route.polyline.map(
      point => new window.kakao.maps.LatLng(point.lat, point.lng)
    );
    
    const polyline = new window.kakao.maps.Polyline({
      path,
      strokeWeight: 5,
      strokeColor: '#3B82F6',
      strokeOpacity: 0.8,
      strokeStyle: 'solid',
    });
    
    polyline.setMap(mapInstance);
    
    const display: RouteDisplay = {
      id: route.id,
      route,
      remove: () => {
        polyline.setMap(null);
        this.routeDisplays.delete(route.id);
      },
      highlight: () => {
        polyline.setOptions({
          strokeWeight: 7,
          strokeColor: '#2563EB',
        });
      },
      unhighlight: () => {
        polyline.setOptions({
          strokeWeight: 5,
          strokeColor: '#3B82F6',
        });
      },
    };
    
    this.routeDisplays.set(route.id, display);
    return display;
  }
  
  removeRoute(routeDisplay: RouteDisplay): void {
    routeDisplay.remove();
  }
  
  getName(): string {
    return 'Kakao';
  }
  
  getSupportedTravelModes(): string[] {
    return ['driving', 'walking'];
  }
  
  getMaxWaypoints(): number {
    return 5; // ì¶œë°œì§€ + ê²½ìœ ì§€ 3ê°œ + ëª©ì ì§€
  }
  
  private mapTravelModeToKakao(mode: string): string {
    switch (mode) {
      case 'driving':
        return 'ROAD';
      case 'walking':
        return 'WALK';
      default:
        return 'ROAD';
    }
  }
}
```

---

## 5. í–‰ì •ê²½ê³„ ë ˆì´ì–´ êµ¬í˜„ ì˜ˆì‹œ

### layers/AdministrativeBoundaryLayer.tsx

```typescript
// layers/AdministrativeBoundaryLayer.tsx

import { Layer, LayerConfig, LayerType } from './BaseLayer';
import { MapProvider } from '../map-providers/BaseMapProvider';
import { VWorldAPI } from '../utils/api/vworldApi';

export class AdministrativeBoundaryLayer implements Layer {
  private config: LayerConfig;
  private mapProvider: MapProvider | null = null;
  private polygons: any[] = [];
  private level: 'sido' | 'sigungu' | 'emd' = 'sido';
  
  constructor(config: LayerConfig) {
    this.config = config;
    // configì—ì„œ level ì¶”ì¶œ (ì˜ˆ: config.options?.level)
  }
  
  getId(): string {
    return this.config.id;
  }
  
  getType(): LayerType {
    return LayerType.ADMINISTRATIVE_BOUNDARY;
  }
  
  getName(): string {
    return this.config.name;
  }
  
  show(): void {
    this.config.visible = true;
    this.updateVisibility();
  }
  
  hide(): void {
    this.config.visible = false;
    this.updateVisibility();
  }
  
  isVisible(): boolean {
    return this.config.visible;
  }
  
  setOpacity(opacity: number): void {
    this.config.opacity = Math.max(0, Math.min(1, opacity));
    this.updateOpacity();
  }
  
  getOpacity(): number {
    return this.config.opacity;
  }
  
  setZIndex(zIndex: number): void {
    this.config.zIndex = zIndex;
    this.updateZIndex();
  }
  
  getZIndex(): number {
    return this.config.zIndex;
  }
  
  async attachToMap(mapProvider: MapProvider): Promise<void> {
    this.mapProvider = mapProvider;
    const mapInstance = mapProvider.getMapInstance();
    
    if (!mapInstance) {
      throw new Error('Map instance not available');
    }
    
    // VWorld APIë¡œ í–‰ì •ê²½ê³„ ë°ì´í„° ì¡°íšŒ
    const boundaries = await VWorldAPI.getAdministrativeBoundaries(this.level);
    
    // ë§µ ì œê³µìë³„ë¡œ í´ë¦¬ê³¤ ìƒì„±
    this.polygons = boundaries.map(boundary => {
      return this.createPolygon(boundary, mapProvider);
    });
    
    if (this.config.visible) {
      this.updateVisibility();
    }
  }
  
  detachFromMap(): void {
    this.hide();
    this.mapProvider = null;
  }
  
  private createPolygon(boundary: any, mapProvider: MapProvider): any {
    const mapInstance = mapProvider.getMapInstance();
    const providerName = mapProvider.getName();
    
    // ë§µ ì œê³µìë³„ êµ¬í˜„
    if (providerName === 'Kakao') {
      const path = boundary.coordinates.map((coord: number[]) =>
        new window.kakao.maps.LatLng(coord[1], coord[0])
      );
      
      return new window.kakao.maps.Polygon({
        path,
        strokeWeight: 2,
        strokeColor: '#3B82F6',
        strokeOpacity: this.config.opacity,
        strokeStyle: 'dashed',
        fillColor: '#3B82F6',
        fillOpacity: this.config.opacity * 0.1,
        zIndex: this.config.zIndex,
      });
    } else if (providerName === 'Google') {
      const path = boundary.coordinates.map((coord: number[]) => ({
        lat: coord[1],
        lng: coord[0],
      }));
      
      return new window.google.maps.Polygon({
        paths: path,
        strokeWeight: 2,
        strokeColor: '#3B82F6',
        strokeOpacity: this.config.opacity,
        fillColor: '#3B82F6',
        fillOpacity: this.config.opacity * 0.1,
        zIndex: this.config.zIndex,
      });
    }
    // ê¸°íƒ€ ì œê³µì êµ¬í˜„...
    
    return null;
  }
  
  private updateVisibility(): void {
    if (!this.mapProvider) return;
    
    const mapInstance = this.mapProvider.getMapInstance();
    this.polygons.forEach(polygon => {
      if (polygon) {
        if (this.config.visible) {
          polygon.setMap(mapInstance);
        } else {
          polygon.setMap(null);
        }
      }
    });
  }
  
  private updateOpacity(): void {
    this.polygons.forEach(polygon => {
      if (polygon) {
        // ë§µ ì œê³µìë³„ë¡œ opacity ì—…ë°ì´íŠ¸
        if (polygon.setOptions) {
          polygon.setOptions({
            strokeOpacity: this.config.opacity,
            fillOpacity: this.config.opacity * 0.1,
          });
        }
      }
    });
  }
  
  private updateZIndex(): void {
    this.polygons.forEach(polygon => {
      if (polygon && polygon.setZIndex) {
        polygon.setZIndex(this.config.zIndex);
      }
    });
  }
  
  cleanup(): void {
    this.polygons.forEach(polygon => {
      if (polygon && polygon.setMap) {
        polygon.setMap(null);
      }
    });
    this.polygons = [];
    this.mapProvider = null;
  }
}
```

---

## 6. ë¦¬íŒ©í† ë§ëœ MapPane.tsx ì˜ˆì‹œ

### components/MapPane.tsx (ë¦¬íŒ©í† ë§ í›„)

```typescript
// components/MapPane.tsx

import React, { useEffect, useRef } from 'react';
import { MapVendor, MapState, PaneConfig } from '../types';
import { useMapProvider } from '../hooks/useMapProvider';
import { useMapSync } from '../hooks/useMapSync';
import { useStreetView } from '../hooks/useStreetView';
import { useLayerManager } from '../hooks/useLayerManager';
import { useRouting } from '../hooks/useRouting';
import { MapProviderFactory } from '../map-providers/MapProviderFactory';

interface MapPaneProps {
  side: 'left' | 'right';
  config: PaneConfig;
  globalState: MapState;
  onStateChange: (state: MapState) => void;
  searchPos: { lat: number, lng: number } | null;
  isFullscreen: boolean;
  onToggleFullscreen: () => void;
  streetViewState: { lat: number, lng: number, active: boolean } | null;
  onStreetViewChange: (state: { lat: number, lng: number, active: boolean } | null) => void;
}

const MapPane: React.FC<MapPaneProps> = ({
  side,
  config,
  globalState,
  onStateChange,
  searchPos,
  isFullscreen,
  onToggleFullscreen,
  streetViewState,
  onStreetViewChange,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  
  // ë§µ ì œê³µì ê´€ë¦¬
  const { provider, sdkLoaded } = useMapProvider(
    config,
    globalState,
    onStateChange,
    containerRef
  );
  
  // ë§µ ë™ê¸°í™”
  useMapSync(provider, globalState, onStateChange);
  
  // ê±°ë¦¬ë·° ê´€ë¦¬
  useStreetView(provider, streetViewState, onStreetViewChange);
  
  // ë ˆì´ì–´ ê´€ë¦¬
  const layerManager = useLayerManager(provider);
  
  // ê¸¸ì°¾ê¸° ê´€ë¦¬
  const routingManager = useRouting(provider, config.type);
  
  // ë§ˆì»¤ ì„¤ì •
  useEffect(() => {
    if (provider && searchPos) {
      provider.setMarker(searchPos);
    }
  }, [provider, searchPos]);
  
  return (
    <div className="w-full h-full relative">
      <div ref={containerRef} className="w-full h-full" />
      
      {/* ë¡œë”© í‘œì‹œ */}
      {!sdkLoaded && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 z-[120] text-gray-500">
          <span>Loading...</span>
        </div>
      )}
      
      {/* ì „ì²´í™”ë©´ ë²„íŠ¼ */}
      <button
        onClick={onToggleFullscreen}
        className="absolute top-4 right-4 z-[9999] bg-white p-1.5 rounded shadow border border-gray-300 hover:bg-gray-50 transition-colors"
        title="ì „ì²´í™”ë©´"
      >
        {/* ì•„ì´ì½˜ */}
      </button>
      
      {/* ë ˆì´ì–´ ì»¨íŠ¸ë¡¤ */}
      {provider && (
        <LayerControlPanel layerManager={layerManager} />
      )}
      
      {/* ê¸¸ì°¾ê¸° ì»¨íŠ¸ë¡¤ */}
      {provider && (
        <RoutingControlPanel routingManager={routingManager} />
      )}
    </div>
  );
};

export default MapPane;
```

---

ì´ êµ¬í˜„ ì˜ˆì‹œëŠ” í™•ì¥ì„±ì„ ê³ ë ¤í•œ ë¦¬íŒ©í† ë§ì˜ êµ¬ì²´ì ì¸ ë°©í–¥ì„ ì œì‹œí•©ë‹ˆë‹¤. ê° ëª¨ë“ˆì€ ë…ë¦½ì ìœ¼ë¡œ ê°œë°œí•˜ê³  í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìœ¼ë©°, ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ê°€ ìš©ì´í•©ë‹ˆë‹¤.
