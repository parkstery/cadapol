# í™•ì¥ì„± ê³ ë ¤ ë¦¬íŒ©í† ë§ ì „ëµ

**ì‘ì„±ì¼**: 2026ë…„ 1ì›” 18ì¼  
**í”„ë¡œì íŠ¸ëª…**: Cadapol (Advanced Dual Map Viewer)  
**ëª©í‘œ**: ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ ë° í–¥í›„ ê¸°ëŠ¥ í™•ëŒ€ ëŒ€ë¹„

---

## ëª©ì°¨

1. [ë¦¬íŒ©í† ë§ ëª©í‘œ ë° ì›ì¹™](#1-ë¦¬íŒ©í† ë§-ëª©í‘œ-ë°-ì›ì¹™)
2. [í–¥í›„ ê¸°ëŠ¥ í™•ëŒ€ ê³„íš](#2-í–¥í›„-ê¸°ëŠ¥-í™•ëŒ€-ê³„íš)
3. [ëª©í‘œ ì•„í‚¤í…ì²˜](#3-ëª©í‘œ-ì•„í‚¤í…ì²˜)
4. [ìƒì„¸ ì„¤ê³„](#4-ìƒì„¸-ì„¤ê³„)
5. [ë‹¨ê³„ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš](#5-ë‹¨ê³„ë³„-ë§ˆì´ê·¸ë ˆì´ì…˜-ê³„íš)
6. [êµ¬í˜„ ê°€ì´ë“œ](#6-êµ¬í˜„-ê°€ì´ë“œ)
7. [í…ŒìŠ¤íŠ¸ ì „ëµ](#7-í…ŒìŠ¤íŠ¸-ì „ëµ)
8. [ê²°ë¡ ](#8-ê²°ë¡ )

---

## 1. ë¦¬íŒ©í† ë§ ëª©í‘œ ë° ì›ì¹™

### 1.1 í•µì‹¬ ëª©í‘œ

1. **ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ**: ì½”ë“œ ê°€ë…ì„± ë° êµ¬ì¡° ê°œì„ 
2. **í™•ì¥ì„± í™•ë³´**: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ê°€ ìš©ì´í•œ êµ¬ì¡°
3. **ì¬ì‚¬ìš©ì„±**: ì»´í¬ë„ŒíŠ¸ ë° ë¡œì§ ì¬ì‚¬ìš© ê°€ëŠ¥
4. **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±**: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸ ìš©ì´

### 1.2 ì„¤ê³„ ì›ì¹™

- **SOLID ì›ì¹™** ì¤€ìˆ˜
- **ì „ëµ íŒ¨í„´**: ë§µ ì œê³µìë³„ ë…ë¦½ êµ¬í˜„
- **íŒ©í† ë¦¬ íŒ¨í„´**: ë§µ ì œê³µì ìƒì„±
- **ì˜µì €ë²„ íŒ¨í„´**: ì´ë²¤íŠ¸ ë° ìƒíƒœ ë™ê¸°í™”
- **ì˜ì¡´ì„± ì£¼ì…**: ëŠìŠ¨í•œ ê²°í•©

### 1.3 í˜„ì¬ ë¬¸ì œì 

- âŒ ë‹¨ì¼ íŒŒì¼ì— ëª¨ë“  ë¡œì§ ì§‘ì¤‘ (3,106 lines)
- âŒ ë§µ ì œê³µìë³„ ë¡œì§ì´ ê°•í•˜ê²Œ ê²°í•©
- âŒ ë ˆì´ì–´ ê´€ë¦¬ê°€ ì œê³µìë³„ë¡œ ë¶„ì‚°
- âŒ ê¸¸ì°¾ê¸° ê¸°ëŠ¥ì„ ìœ„í•œ êµ¬ì¡° ë¶€ì¬
- âŒ ìƒˆë¡œìš´ ë§µ ì œê³µì ì¶”ê°€ê°€ ì–´ë ¤ì›€

---

## 2. í–¥í›„ ê¸°ëŠ¥ í™•ëŒ€ ê³„íš

### 2.1 ë§µ ì œê³µì ì¶”ê°€

**ì¶”ê°€ ì˜ˆì •**:
- **VWorld Map**: êµ­í† êµí†µë¶€ ê³µê³µ ì§€ë„
- **OpenStreetMap (OSM)**: ì˜¤í”ˆì†ŒìŠ¤ ì§€ë„

**ìš”êµ¬ì‚¬í•­**:
- ê¸°ì¡´ ë§µ ì œê³µìì™€ ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤
- ë…ë¦½ì ì¸ ì´ˆê¸°í™” ë° ê´€ë¦¬
- ë™ê¸°í™” ì§€ì›

### 2.2 ê¸¸ì°¾ê¸° ê¸°ëŠ¥

**ê¸°ëŠ¥ ëª…ì„¸**:
- ì¶œë°œì§€ ì„¤ì •
- ëª©ì ì§€ ì„¤ì •
- ê²½ìœ ì§€ 1~4ê°œ ì„¤ì •
- ê²½ë¡œ í‘œì‹œ
- ê²½ë¡œ ì •ë³´ í‘œì‹œ (ê±°ë¦¬, ì‹œê°„)

**ìš”êµ¬ì‚¬í•­**:
- ì—¬ëŸ¬ ë§µ ì œê³µìì—ì„œ ì§€ì›
- ê²½ë¡œ ë¹„êµ ê¸°ëŠ¥
- ê²½ë¡œ ë‚´ë³´ë‚´ê¸°/ê³µìœ 

### 2.3 Layer ì¤‘ì²© ê¸°ëŠ¥

**ì¶”ê°€ ì˜ˆì • ë ˆì´ì–´**:
- **í–‰ì •ê²½ê³„**: ì‹œ/ë„, ì‹œ/êµ°/êµ¬, ì/ë©´/ë™ ê²½ê³„
- **ì§€í˜•ë„**: ë“±ê³ ì„ , ì§€í˜• ì •ë³´

**ìš”êµ¬ì‚¬í•­**:
- ì—¬ëŸ¬ ë ˆì´ì–´ ë™ì‹œ í‘œì‹œ
- ë ˆì´ì–´ë³„ í† ê¸€
- ë ˆì´ì–´ ìˆœì„œ ì¡°ì • (Z-index)
- ë ˆì´ì–´ íˆ¬ëª…ë„ ì¡°ì •

---

## 3. ëª©í‘œ ì•„í‚¤í…ì²˜

### 3.1 ì „ì²´ êµ¬ì¡°

```
components/
â”œâ”€â”€ MapPane.tsx                          # ë©”ì¸ ì»´í¬ë„ŒíŠ¸ (~200 lines)
â”‚
â”œâ”€â”€ map-providers/                       # ë§µ ì œê³µì ëª¨ë“ˆ
â”‚   â”œâ”€â”€ BaseMapProvider.ts               # ê³µí†µ ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ GoogleMapProvider.tsx
â”‚   â”œâ”€â”€ KakaoMapProvider.tsx
â”‚   â”œâ”€â”€ NaverMapProvider.tsx
â”‚   â”œâ”€â”€ VWorldMapProvider.tsx            # ğŸ†•
â”‚   â””â”€â”€ OSMMapProvider.tsx                # ğŸ†•
â”‚
â”œâ”€â”€ streetview/                          # ê±°ë¦¬ë·° ëª¨ë“ˆ
â”‚   â”œâ”€â”€ BaseStreetViewProvider.ts
â”‚   â”œâ”€â”€ GoogleStreetView.tsx
â”‚   â”œâ”€â”€ KakaoRoadView.tsx
â”‚   â””â”€â”€ NaverPanorama.tsx
â”‚
â”œâ”€â”€ layers/                              # ğŸ†• ë ˆì´ì–´ ê´€ë¦¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ BaseLayer.ts                     # ë ˆì´ì–´ ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ LayerManager.tsx                 # ë ˆì´ì–´ ê´€ë¦¬ì
â”‚   â”œâ”€â”€ CadastralLayer.tsx               # ì§€ì ë„ ë ˆì´ì–´
â”‚   â”œâ”€â”€ AdministrativeBoundaryLayer.tsx  # ğŸ†• í–‰ì •ê²½ê³„ ë ˆì´ì–´
â”‚   â””â”€â”€ TopographicLayer.tsx              # ğŸ†• ì§€í˜•ë„ ë ˆì´ì–´
â”‚
â”œâ”€â”€ routing/                             # ğŸ†• ê¸¸ì°¾ê¸° ëª¨ë“ˆ
â”‚   â”œâ”€â”€ BaseRoutingProvider.ts
â”‚   â”œâ”€â”€ RoutingManager.tsx
â”‚   â”œâ”€â”€ RouteDisplay.tsx
â”‚   â”œâ”€â”€ WaypointManager.tsx
â”‚   â””â”€â”€ providers/
â”‚       â”œâ”€â”€ GoogleRoutingProvider.tsx
â”‚       â”œâ”€â”€ KakaoRoutingProvider.tsx
â”‚       â””â”€â”€ NaverRoutingProvider.tsx
â”‚
â”œâ”€â”€ gis-tools/                           # GIS ë„êµ¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ BaseGisTool.ts
â”‚   â”œâ”€â”€ DistanceMeasure.tsx
â”‚   â”œâ”€â”€ AreaMeasure.tsx
â”‚   â””â”€â”€ CadastralInfo.tsx
â”‚
â”œâ”€â”€ hooks/                               # ì»¤ìŠ¤í…€ í›…
â”‚   â”œâ”€â”€ useMapProvider.ts
â”‚   â”œâ”€â”€ useMapSync.ts
â”‚   â”œâ”€â”€ useStreetView.ts
â”‚   â”œâ”€â”€ useLayerManager.ts               # ğŸ†•
â”‚   â””â”€â”€ useRouting.ts                    # ğŸ†•
â”‚
â””â”€â”€ utils/                               # ìœ í‹¸ë¦¬í‹°
    â”œâ”€â”€ coordinateTransform.ts
    â”œâ”€â”€ api/
    â”‚   â”œâ”€â”€ vworldApi.ts
    â”‚   â””â”€â”€ routingApi.ts                # ğŸ†•
    â””â”€â”€ constants.ts
```

### 3.2 í•µì‹¬ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

#### 3.2.1 BaseMapProvider

```typescript
// map-providers/BaseMapProvider.ts

export interface MapProviderConfig {
  container: HTMLElement;
  initialState: MapState;
  isSatellite: boolean;
  onStateChange: (state: MapState) => void;
}

export interface MapProvider {
  // ì´ˆê¸°í™”
  init(config: MapProviderConfig): Promise<void>;
  
  // ìƒíƒœ ê´€ë¦¬
  syncState(state: MapState): void;
  getState(): MapState;
  
  // ì„¤ì •
  setSatelliteMode(enabled: boolean): void;
  setZoom(zoom: number): void;
  setCenter(lat: number, lng: number): void;
  
  // ë§ˆì»¤
  setMarker(position: { lat: number; lng: number } | null): void;
  addMarker(position: { lat: number; lng: number }, options?: MarkerOptions): Marker;
  removeMarker(marker: Marker): void;
  
  // ë ˆì´ì–´ ê´€ë¦¬ (ğŸ†•)
  addLayer(layer: Layer): void;
  removeLayer(layer: Layer): void;
  getLayers(): Layer[];
  
  // ì´ë²¤íŠ¸
  on(event: string, handler: Function): void;
  off(event: string, handler: Function): void;
  
  // ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
  cleanup(): void;
  
  // ì¸ìŠ¤í„´ìŠ¤ ì ‘ê·¼
  getMapInstance(): any;
  
  // ì œê³µì ì •ë³´
  getName(): string;
  getCapabilities(): MapCapabilities;
}

export interface MapCapabilities {
  supportsStreetView: boolean;
  supportsRouting: boolean;
  supportsLayers: boolean;
  supportedLayerTypes: LayerType[];
}

export interface Marker {
  id: string;
  position: { lat: number; lng: number };
  remove(): void;
  updatePosition(position: { lat: number; lng: number }): void;
}

export interface MarkerOptions {
  icon?: string | { url: string; size?: { width: number; height: number } };
  title?: string;
  draggable?: boolean;
}
```

#### 3.2.2 BaseLayer

```typescript
// layers/BaseLayer.ts

export enum LayerType {
  CADASTRAL = 'cadastral',              // ì§€ì ë„
  ADMINISTRATIVE_BOUNDARY = 'administrative_boundary', // í–‰ì •ê²½ê³„
  TOPOGRAPHIC = 'topographic',          // ì§€í˜•ë„
  CUSTOM = 'custom'                     // ì‚¬ìš©ì ì •ì˜
}

export interface LayerConfig {
  id: string;
  type: LayerType;
  name: string;
  visible: boolean;
  opacity: number;  // 0.0 ~ 1.0
  zIndex: number;
  provider?: MapVendor;  // íŠ¹ì • ì œê³µìì—ì„œë§Œ ì§€ì›
}

export interface Layer {
  // ê¸°ë³¸ ì •ë³´
  getId(): string;
  getType(): LayerType;
  getName(): string;
  
  // í‘œì‹œ ì œì–´
  show(): void;
  hide(): void;
  isVisible(): boolean;
  setOpacity(opacity: number): void;
  getOpacity(): number;
  setZIndex(zIndex: number): void;
  getZIndex(): number;
  
  // ë§µ ì—°ê²°
  attachToMap(mapProvider: MapProvider): void;
  detachFromMap(): void;
  
  // ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
  cleanup(): void;
}
```

#### 3.2.3 BaseRoutingProvider

```typescript
// routing/BaseRoutingProvider.ts

export interface Waypoint {
  id: string;
  position: { lat: number; lng: number };
  label?: string;
  order: number;  // 0: ì¶œë°œì§€, 1~4: ê²½ìœ ì§€, ë§ˆì§€ë§‰: ëª©ì ì§€
}

export interface RouteOptions {
  waypoints: Waypoint[];
  travelMode?: 'driving' | 'walking' | 'transit' | 'bicycling';
  avoidTolls?: boolean;
  avoidHighways?: boolean;
  optimizeWaypoints?: boolean;
}

export interface Route {
  id: string;
  distance: number;  // ë¯¸í„°
  duration: number;  // ì´ˆ
  polyline: Array<{ lat: number; lng: number }>;
  steps?: RouteStep[];
}

export interface RouteStep {
  instruction: string;
  distance: number;
  duration: number;
  polyline: Array<{ lat: number; lng: number }>;
}

export interface RoutingProvider {
  // ê²½ë¡œ ê³„ì‚°
  calculateRoute(options: RouteOptions): Promise<Route[]>;
  
  // ê²½ë¡œ í‘œì‹œ
  displayRoute(route: Route, mapProvider: MapProvider): RouteDisplay;
  removeRoute(routeDisplay: RouteDisplay): void;
  
  // ì œê³µì ì •ë³´
  getName(): string;
  getSupportedTravelModes(): string[];
  getMaxWaypoints(): number;
}

export interface RouteDisplay {
  id: string;
  route: Route;
  remove(): void;
  highlight(): void;
  unhighlight(): void;
}
```

---

## 4. ìƒì„¸ ì„¤ê³„

### 4.1 ë§µ ì œê³µì íŒ©í† ë¦¬

```typescript
// map-providers/MapProviderFactory.ts

import { GoogleMapProvider } from './GoogleMapProvider';
import { KakaoMapProvider } from './KakaoMapProvider';
import { NaverMapProvider } from './NaverMapProvider';
import { VWorldMapProvider } from './VWorldMapProvider';
import { OSMMapProvider } from './OSMMapProvider';
import { MapProvider, MapVendor } from './BaseMapProvider';

export class MapProviderFactory {
  static create(vendor: MapVendor): MapProvider {
    switch (vendor) {
      case 'google':
        return new GoogleMapProvider();
      case 'kakao':
        return new KakaoMapProvider();
      case 'naver':
        return new NaverMapProvider();
      case 'vworld':
        return new VWorldMapProvider();
      case 'osm':
        return new OSMMapProvider();
      default:
        throw new Error(`Unsupported map vendor: ${vendor}`);
    }
  }
  
  static getSupportedVendors(): MapVendor[] {
    return ['google', 'kakao', 'naver', 'vworld', 'osm'];
  }
}
```

### 4.2 ë ˆì´ì–´ ê´€ë¦¬ì

```typescript
// layers/LayerManager.tsx

import React, { useState, useCallback } from 'react';
import { Layer, LayerConfig, LayerType } from './BaseLayer';
import { MapProvider } from '../map-providers/BaseMapProvider';
import { CadastralLayer } from './CadastralLayer';
import { AdministrativeBoundaryLayer } from './AdministrativeBoundaryLayer';
import { TopographicLayer } from './TopographicLayer';

interface LayerManagerProps {
  mapProvider: MapProvider | null;
}

export const LayerManager: React.FC<LayerManagerProps> = ({ mapProvider }) => {
  const [layers, setLayers] = useState<Map<string, Layer>>(new Map());
  
  const addLayer = useCallback((config: LayerConfig) => {
    let layer: Layer;
    
    switch (config.type) {
      case LayerType.CADASTRAL:
        layer = new CadastralLayer(config);
        break;
      case LayerType.ADMINISTRATIVE_BOUNDARY:
        layer = new AdministrativeBoundaryLayer(config);
        break;
      case LayerType.TOPOGRAPHIC:
        layer = new TopographicLayer(config);
        break;
      default:
        throw new Error(`Unsupported layer type: ${config.type}`);
    }
    
    if (mapProvider) {
      layer.attachToMap(mapProvider);
    }
    
    setLayers(prev => new Map(prev).set(config.id, layer));
  }, [mapProvider]);
  
  const removeLayer = useCallback((layerId: string) => {
    const layer = layers.get(layerId);
    if (layer) {
      layer.detachFromMap();
      layer.cleanup();
      setLayers(prev => {
        const next = new Map(prev);
        next.delete(layerId);
        return next;
      });
    }
  }, [layers]);
  
  const toggleLayer = useCallback((layerId: string) => {
    const layer = layers.get(layerId);
    if (layer) {
      if (layer.isVisible()) {
        layer.hide();
      } else {
        layer.show();
      }
    }
  }, [layers]);
  
  const updateLayerOpacity = useCallback((layerId: string, opacity: number) => {
    const layer = layers.get(layerId);
    if (layer) {
      layer.setOpacity(opacity);
    }
  }, [layers]);
  
  // ë§µ ì œê³µì ë³€ê²½ ì‹œ ë ˆì´ì–´ ì¬ì—°ê²°
  React.useEffect(() => {
    if (mapProvider) {
      layers.forEach(layer => {
        layer.detachFromMap();
        layer.attachToMap(mapProvider);
      });
    }
  }, [mapProvider, layers]);
  
  return {
    layers: Array.from(layers.values()),
    addLayer,
    removeLayer,
    toggleLayer,
    updateLayerOpacity,
  };
};
```

### 4.3 ê¸¸ì°¾ê¸° ê´€ë¦¬ì

```typescript
// routing/RoutingManager.tsx

import React, { useState, useCallback } from 'react';
import { RoutingProvider, Route, RouteOptions, Waypoint } from './BaseRoutingProvider';
import { MapProvider } from '../map-providers/BaseMapProvider';
import { GoogleRoutingProvider } from './providers/GoogleRoutingProvider';
import { KakaoRoutingProvider } from './providers/KakaoRoutingProvider';
import { NaverRoutingProvider } from './providers/NaverRoutingProvider';

interface RoutingManagerProps {
  mapProvider: MapProvider | null;
  mapVendor: MapVendor;
}

export const RoutingManager: React.FC<RoutingManagerProps> = ({ mapProvider, mapVendor }) => {
  const [waypoints, setWaypoints] = useState<Waypoint[]>([]);
  const [routes, setRoutes] = useState<Route[]>([]);
  const [activeRoute, setActiveRoute] = useState<Route | null>(null);
  
  const routingProvider = React.useMemo(() => {
    switch (mapVendor) {
      case 'google':
        return new GoogleRoutingProvider();
      case 'kakao':
        return new KakaoRoutingProvider();
      case 'naver':
        return new NaverRoutingProvider();
      default:
        return null;
    }
  }, [mapVendor]);
  
  const addWaypoint = useCallback((position: { lat: number; lng: number }, label?: string) => {
    const waypoint: Waypoint = {
      id: `waypoint-${Date.now()}`,
      position,
      label,
      order: waypoints.length,
    };
    
    setWaypoints(prev => [...prev, waypoint]);
  }, [waypoints.length]);
  
  const removeWaypoint = useCallback((waypointId: string) => {
    setWaypoints(prev => {
      const filtered = prev.filter(w => w.id !== waypointId);
      // ìˆœì„œ ì¬ì •ë ¬
      return filtered.map((w, index) => ({ ...w, order: index }));
    });
  }, []);
  
  const calculateRoute = useCallback(async (options: RouteOptions) => {
    if (!routingProvider || waypoints.length < 2) {
      return;
    }
    
    try {
      const calculatedRoutes = await routingProvider.calculateRoute({
        ...options,
        waypoints: waypoints.length > 0 ? waypoints : options.waypoints,
      });
      
      setRoutes(calculatedRoutes);
      
      // ì²« ë²ˆì§¸ ê²½ë¡œë¥¼ ê¸°ë³¸ìœ¼ë¡œ í‘œì‹œ
      if (calculatedRoutes.length > 0 && mapProvider) {
        const routeDisplay = routingProvider.displayRoute(calculatedRoutes[0], mapProvider);
        setActiveRoute(calculatedRoutes[0]);
      }
    } catch (error) {
      console.error('Route calculation failed:', error);
      // ì‚¬ìš©ìì—ê²Œ ì—ëŸ¬ ì•Œë¦¼
    }
  }, [routingProvider, waypoints, mapProvider]);
  
  const clearRoute = useCallback(() => {
    if (activeRoute && routingProvider && mapProvider) {
      // ê²½ë¡œ í‘œì‹œ ì œê±° ë¡œì§
    }
    setRoutes([]);
    setActiveRoute(null);
  }, [activeRoute, routingProvider, mapProvider]);
  
  return {
    waypoints,
    routes,
    activeRoute,
    addWaypoint,
    removeWaypoint,
    calculateRoute,
    clearRoute,
    maxWaypoints: routingProvider?.getMaxWaypoints() || 0,
  };
};
```

### 4.4 í–‰ì •ê²½ê³„ ë ˆì´ì–´ êµ¬í˜„ ì˜ˆì‹œ

```typescript
// layers/AdministrativeBoundaryLayer.tsx

import { Layer, LayerConfig, LayerType } from './BaseLayer';
import { MapProvider } from '../map-providers/BaseMapProvider';
import { VWorldAPI } from '../utils/api/vworldApi';

export class AdministrativeBoundaryLayer implements Layer {
  private config: LayerConfig;
  private mapProvider: MapProvider | null = null;
  private polygons: any[] = [];
  private level: 'sido' | 'sigungu' | 'emd' = 'sido';
  
  constructor(config: LayerConfig) {
    this.config = config;
  }
  
  getId(): string {
    return this.config.id;
  }
  
  getType(): LayerType {
    return LayerType.ADMINISTRATIVE_BOUNDARY;
  }
  
  getName(): string {
    return this.config.name;
  }
  
  show(): void {
    this.config.visible = true;
    this.polygons.forEach(polygon => {
      // ë§µ ì œê³µìë³„ë¡œ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
      if (this.mapProvider) {
        const mapInstance = this.mapProvider.getMapInstance();
        // polygon.setMap(mapInstance);
      }
    });
  }
  
  hide(): void {
    this.config.visible = false;
    this.polygons.forEach(polygon => {
      // polygon.setMap(null);
    });
  }
  
  isVisible(): boolean {
    return this.config.visible;
  }
  
  setOpacity(opacity: number): void {
    this.config.opacity = opacity;
    this.polygons.forEach(polygon => {
      // polygon.setOptions({ fillOpacity: opacity });
    });
  }
  
  getOpacity(): number {
    return this.config.opacity;
  }
  
  setZIndex(zIndex: number): void {
    this.config.zIndex = zIndex;
    this.polygons.forEach(polygon => {
      // polygon.setZIndex(zIndex);
    });
  }
  
  getZIndex(): number {
    return this.config.zIndex;
  }
  
  async attachToMap(mapProvider: MapProvider): Promise<void> {
    this.mapProvider = mapProvider;
    
    // VWorld APIë¡œ í–‰ì •ê²½ê³„ ë°ì´í„° ì¡°íšŒ
    const boundaries = await VWorldAPI.getAdministrativeBoundaries(this.level);
    
    // í´ë¦¬ê³¤ ìƒì„±
    this.polygons = boundaries.map(boundary => {
      // ë§µ ì œê³µìë³„ë¡œ í´ë¦¬ê³¤ ìƒì„±
      return this.createPolygon(boundary, mapProvider);
    });
    
    if (this.config.visible) {
      this.show();
    }
  }
  
  detachFromMap(): void {
    this.hide();
    this.mapProvider = null;
  }
  
  private createPolygon(boundary: any, mapProvider: MapProvider): any {
    // ë§µ ì œê³µìë³„ êµ¬í˜„
    const mapInstance = mapProvider.getMapInstance();
    // ...
  }
  
  cleanup(): void {
    this.polygons.forEach(polygon => {
      // polygon ì œê±°
    });
    this.polygons = [];
    this.mapProvider = null;
  }
}
```

---

## 5. ë‹¨ê³„ë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš

### Phase 1: ê¸°ë°˜ êµ¬ì¡° êµ¬ì¶• (1ì£¼)

**ëª©í‘œ**: ì¸í„°í˜ì´ìŠ¤ ë° ê¸°ë³¸ êµ¬ì¡° ìƒì„±

1. **ì¸í„°í˜ì´ìŠ¤ ì •ì˜**
   - `BaseMapProvider` ì¸í„°í˜ì´ìŠ¤
   - `BaseLayer` ì¸í„°í˜ì´ìŠ¤
   - `BaseRoutingProvider` ì¸í„°í˜ì´ìŠ¤
   - íƒ€ì… ì •ì˜ ì •ë¦¬

2. **ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±**
   - ëª¨ë“  ëª¨ë“ˆ ë””ë ‰í† ë¦¬ ìƒì„±
   - ë¹ˆ íŒŒì¼ ìƒì„±

3. **íŒ©í† ë¦¬ íŒ¨í„´ êµ¬í˜„**
   - `MapProviderFactory` êµ¬í˜„

### Phase 2: ê¸°ì¡´ ë§µ ì œê³µì ë¶„ë¦¬ (2ì£¼)

**ëª©í‘œ**: Google, Kakao, Naver ë§µ ì œê³µì ë¶„ë¦¬

1. **GoogleMapProvider êµ¬í˜„** (3ì¼)
2. **KakaoMapProvider êµ¬í˜„** (4ì¼)
3. **NaverMapProvider êµ¬í˜„** (3ì¼)
4. **í†µí•© í…ŒìŠ¤íŠ¸** (2ì¼)

### Phase 3: ë ˆì´ì–´ ì‹œìŠ¤í…œ êµ¬ì¶• (1ì£¼)

**ëª©í‘œ**: ë ˆì´ì–´ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

1. **LayerManager êµ¬í˜„** (2ì¼)
2. **ê¸°ì¡´ ì§€ì ë„ ë ˆì´ì–´ ë¶„ë¦¬** (2ì¼)
3. **í–‰ì •ê²½ê³„ ë ˆì´ì–´ êµ¬í˜„** (2ì¼)
4. **ì§€í˜•ë„ ë ˆì´ì–´ êµ¬í˜„** (1ì¼)

### Phase 4: ê¸¸ì°¾ê¸° ê¸°ëŠ¥ êµ¬í˜„ (2ì£¼)

**ëª©í‘œ**: ê¸¸ì°¾ê¸° ê¸°ëŠ¥ ì¶”ê°€

1. **RoutingManager êµ¬í˜„** (2ì¼)
2. **GoogleRoutingProvider êµ¬í˜„** (2ì¼)
3. **KakaoRoutingProvider êµ¬í˜„** (2ì¼)
4. **NaverRoutingProvider êµ¬í˜„** (2ì¼)
5. **UI ì»´í¬ë„ŒíŠ¸ êµ¬í˜„** (2ì¼)

### Phase 5: ìƒˆ ë§µ ì œê³µì ì¶”ê°€ (1ì£¼)

**ëª©í‘œ**: VWorld, OSM ë§µ ì œê³µì ì¶”ê°€

1. **VWorldMapProvider êµ¬í˜„** (3ì¼)
2. **OSMMapProvider êµ¬í˜„** (2ì¼)
3. **í†µí•© í…ŒìŠ¤íŠ¸** (2ì¼)

### Phase 6: MapPane.tsx ë¦¬íŒ©í† ë§ (1ì£¼)

**ëª©í‘œ**: ë©”ì¸ ì»´í¬ë„ŒíŠ¸ ê°„ì†Œí™”

1. **ìƒˆ êµ¬ì¡°ë¡œ MapPane ì¬ì‘ì„±** (3ì¼)
2. **í†µí•© í…ŒìŠ¤íŠ¸** (2ì¼)
3. **ì„±ëŠ¥ ìµœì í™”** (2ì¼)

**ì´ ì˜ˆìƒ ì‹œê°„**: 8ì£¼

---

## 6. êµ¬í˜„ ê°€ì´ë“œ

### 6.1 ìƒˆ ë§µ ì œê³µì ì¶”ê°€ ë°©ë²•

**Step 1: Provider í´ë˜ìŠ¤ ìƒì„±**

```typescript
// map-providers/VWorldMapProvider.tsx

import { BaseMapProvider, MapProvider, MapProviderConfig } from './BaseMapProvider';

export class VWorldMapProvider implements MapProvider {
  private map: any = null;
  private config: MapProviderConfig | null = null;
  
  async init(config: MapProviderConfig): Promise<void> {
    this.config = config;
    
    // VWorld Map ì´ˆê¸°í™”
    // ...
  }
  
  syncState(state: MapState): void {
    // ìƒíƒœ ë™ê¸°í™”
  }
  
  // ... ê¸°íƒ€ ë©”ì„œë“œ êµ¬í˜„
}
```

**Step 2: Factoryì— ë“±ë¡**

```typescript
// map-providers/MapProviderFactory.ts

import { VWorldMapProvider } from './VWorldMapProvider';

export class MapProviderFactory {
  static create(vendor: MapVendor): MapProvider {
    switch (vendor) {
      // ...
      case 'vworld':
        return new VWorldMapProvider();
      // ...
    }
  }
}
```

**Step 3: íƒ€ì… ì •ì˜ ì—…ë°ì´íŠ¸**

```typescript
// types.ts

export type MapVendor = 'google' | 'kakao' | 'naver' | 'vworld' | 'osm';
```

### 6.2 ìƒˆ ë ˆì´ì–´ ì¶”ê°€ ë°©ë²•

**Step 1: Layer í´ë˜ìŠ¤ ìƒì„±**

```typescript
// layers/TopographicLayer.tsx

import { Layer, LayerConfig, LayerType } from './BaseLayer';

export class TopographicLayer implements Layer {
  // ... êµ¬í˜„
}
```

**Step 2: LayerManagerì— ë“±ë¡**

```typescript
// layers/LayerManager.tsx

case LayerType.TOPOGRAPHIC:
  layer = new TopographicLayer(config);
  break;
```

### 6.3 ê¸¸ì°¾ê¸° ì œê³µì ì¶”ê°€ ë°©ë²•

**Step 1: RoutingProvider êµ¬í˜„**

```typescript
// routing/providers/GoogleRoutingProvider.tsx

import { BaseRoutingProvider, RoutingProvider } from '../BaseRoutingProvider';

export class GoogleRoutingProvider implements RoutingProvider {
  async calculateRoute(options: RouteOptions): Promise<Route[]> {
    // Google Directions API í˜¸ì¶œ
  }
  
  // ... ê¸°íƒ€ ë©”ì„œë“œ
}
```

**Step 2: RoutingManagerì— ë“±ë¡**

```typescript
// routing/RoutingManager.tsx

case 'google':
  return new GoogleRoutingProvider();
```

---

## 7. í…ŒìŠ¤íŠ¸ ì „ëµ

### 7.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

**ëŒ€ìƒ**:
- ê° MapProvider í´ë˜ìŠ¤
- Layer í´ë˜ìŠ¤
- RoutingProvider í´ë˜ìŠ¤
- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

**ë„êµ¬**: Jest, React Testing Library

**ì˜ˆì‹œ**:
```typescript
// __tests__/GoogleMapProvider.test.ts

describe('GoogleMapProvider', () => {
  it('should initialize map correctly', async () => {
    const provider = new GoogleMapProvider();
    const container = document.createElement('div');
    await provider.init({
      container,
      initialState: { lat: 37.5665, lng: 126.9780, zoom: 17 },
      isSatellite: false,
      onStateChange: jest.fn(),
    });
    
    expect(provider.getMapInstance()).toBeTruthy();
  });
});
```

### 7.2 í†µí•© í…ŒìŠ¤íŠ¸

**ëŒ€ìƒ**:
- MapPane ì»´í¬ë„ŒíŠ¸
- LayerManager
- RoutingManager

### 7.3 E2E í…ŒìŠ¤íŠ¸

**ëŒ€ìƒ**:
- ì „ì²´ ì‚¬ìš©ì í”Œë¡œìš°
- ë§µ ë™ê¸°í™”
- ê¸¸ì°¾ê¸° ê¸°ëŠ¥

**ë„êµ¬**: Playwright, Cypress

---

## 8. ê²°ë¡ 

### 8.1 ë¦¬íŒ©í† ë§ íš¨ê³¼

**ì˜ˆìƒ ê°œì„  ì‚¬í•­**:
- âœ… ì½”ë“œ ê°€ë…ì„±: 3,106 lines â†’ ëª¨ë“ˆë³„ 200-500 lines
- âœ… ìœ ì§€ë³´ìˆ˜ì„±: ëª…í™•í•œ ì±…ì„ ë¶„ë¦¬
- âœ… í™•ì¥ì„±: ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ê°€ ìš©ì´
- âœ… í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- âœ… ì¬ì‚¬ìš©ì„±: ì»´í¬ë„ŒíŠ¸ ì¬ì‚¬ìš© ê°€ëŠ¥

### 8.2 ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

**ì›ì¹™**: ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜
- ê¸°ì¡´ ì½”ë“œì™€ ìƒˆ ì½”ë“œ ë³‘í–‰ ìš´ì˜
- ë‹¨ê³„ë³„ ê²€ì¦
- ë¡¤ë°± ê°€ëŠ¥í•œ êµ¬ì¡°

### 8.3 ìš°ì„ ìˆœìœ„

**High Priority**:
1. BaseMapProvider ì¸í„°í˜ì´ìŠ¤ ì •ì˜
2. ê¸°ì¡´ ë§µ ì œê³µì ë¶„ë¦¬
3. MapPane.tsx ë¦¬íŒ©í† ë§

**Medium Priority**:
1. ë ˆì´ì–´ ì‹œìŠ¤í…œ êµ¬ì¶•
2. ê¸¸ì°¾ê¸° ê¸°ëŠ¥ êµ¬í˜„

**Low Priority**:
1. ìƒˆ ë§µ ì œê³µì ì¶”ê°€
2. ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€

---

**ë³´ê³ ì„œ ì‘ì„±ì**: AI ì½”ë“œ ë¶„ì„ ì‹œìŠ¤í…œ  
**ìµœì¢… ìˆ˜ì •ì¼**: 2026ë…„ 1ì›” 18ì¼  
**ì˜ˆìƒ ì™„ë£Œì¼**: 8ì£¼ í›„
